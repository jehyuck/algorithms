A, B = map(int, input().split())

basic_found = (0, 1, 4, 12, 32, 80, 192, 448, 1024, 2304, 5120, 11264, 24576, 53248, 114688, 245760, 524288, 1114112, 2359296, 4980736, 10485760, 22020096, 46137344, 96468992, 201326592, 419430400, 872415232, 1811939328, 3758096384, 7784628224, 16106127360, 33285996544, 68719476736, 141733920768, 292057776128, 601295421440, 1236950581248, 2542620639232, 5222680231936, 10720238370816, 21990232555520, 45079976738816, 92358976733184, 189115999977472, 387028092977152, 791648371998720, 1618481116086272, 3307330976350208, 6755399441055744, 13792273858822144, 28147497671065600, 57420895248973824, 117093590311632896, 238690780250636288, 486388759756013568)


#구현 누적합
#1. 각각 10..0을 만드는데 등장한 1의 갯수를 구한다.
#2. 이 값을 토대로 양 끝에 구할때 등장했던 1의 갯수를 구한다.
#3. 앞의 수는 까지 필요한것, 뒤에수는 해당 수 까지 구한다.
#3. 각 자릿수에 대하여 1이면 그 자릿수를 만드는데 걸린 값을 구한다.
#3. 1이면 왼쪽에 등장한 1의 갯수 * 2**(n - 1) + list[n - 1]를 끝까지 시행한다.
#3. A이면 종료한다. B이면 총 1이 등장한 갯수를 구한다.

a = bin(A)[2:]
b = bin(B)[2:]


def cal_all_one(num):
    N = len(num)
    i = 1
    left_zero_num = 1
    rtn = basic_found[N - 1]
    while i < N:
        if num[i] == '1':
            crt = N - i - 1
            rtn += left_zero_num * (2 ** crt)
            rtn += basic_found[crt]
            left_zero_num += 1
        i += 1

    return rtn


a_answer = cal_all_one(a)
b_answer = cal_all_one(b) + b.count('1')

print(b_answer - a_answer)